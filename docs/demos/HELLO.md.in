GNU Hello demo
==============

[Complete source of the demo](./HELLO.py)

Pylightnix is a library for manipulating immutable data objects. It provides
core API for checking, creating and querying such objects using files and
folders as a data sotrage. One kind of applications which could benefit from
this API is package managers.

The task
--------

We illustrate the basic concepts by designing a toy package manager able to
compile and run the [GNU hello](https://www.gnu.org/software/hello) program.

GNU Hello is a demo application which prints 'Hello world!' on its standard
output. It's purpose is to demonstrate the usage of Automake tools. We will see
how Pylighnix could help us to solve this quest. We assume that the host system
provides an access to the GNU Automake toolchain, that is, paths to Autoconf,
Automake, gcc, etc should present in system PATH variable.

We go through the following plan of actions:

1. Use built-in rules to download and unpack the GNU Hello sources.
2. Define a custom rule for compiling the GNU Hello from sources.
3. Run the application by querying the Pylightnix artifact storage.

Implementation
--------------

Pylightnix offers functions which form a kind of domain-specific language,
embedded in Python language. Our program is a Python script, which could be
executed by a common `python3` interpreter. In this demo we will need certain
standard Python functions. Later we will import Pylightnix functions as needed.

```{.python .cb.nb live_output=true}
from os.path import join
from os import system, chdir, getcwd
from shutil import copytree
from tempfile import TemporaryDirectory
from typing import Any
from subprocess import Popen, PIPE
```

First things first, Pylightnix uses filesystem storage for tracking immutable
data object (or stages) which could depend on each other. This storage is
global, it is the central part of library. In order to check or create it, we
call `initialize`:

```{.python .cb.nb}
from os import environ
from pylightnix import fsinit

environ['PYLIGHTNIX_ROOT']='/tmp/pylightnix_hello_demo'
fsinit(remove_existing=True)
```

### Fetchurl and Unpack stages

Pylightnix allows us to define, check and execute data processing operations
called **Stages**. Stages may be defined by writing Python functions (as we will
do later) or imported from a small builtin collection.


Here we import stages `fetchurl2` and `unpack`, along with other Pylightnix API
functions.

```{.python .cb.nb}
from pylightnix import (fetchurl2, unpack, DRef, RRef, instantiate_inplace,
                        realize_inplace, mklens, selfref)
```

Our goal is to prepare stages for execution by **instantiating** them.
`fetchurl2` is the curl-based web downloader, which accepts the URL address, the
hash and the expected `out` path.  We call `instantiate_inplace` API function on
it and get the `tarball` derivation reference, which identifies both the stage
and its parameters in the Pylightnix storage. No actual work is performed yet.

```{.python .cb.nb}
hello_version = '2.10'

tarball:DRef = \
  instantiate_inplace(
    fetchurl2,
    name='hello-src',
    url=f'http://ftp.gnu.org/gnu/hello/hello-{hello_version}.tar.gz',
    sha256='31e066137a962676e89f69d1b65382de95a7ef7d914b8cb956f41ea72e0f516b',
    out=[selfref, f'hello-{hello_version}.tar.gz'])
```

Next we pass the path to the tarball to the `unpack` stage by dereferencing its
`out` attribute using the [mklens](../Reference.md#pylightnix.lens.mklens)
helper function. Pylightnix notes the fact that `unpack` has a reference to
`tarball` in its configuration.

```{.python .cb.nb}
hello_src:DRef = \
  instantiate_inplace(
    unpack,
    name='unpack-hello',
    refpath=mklens(tarball).out.refpath,
    src=[selfref, f'hello-{hello_version}'])
```

Now, we ask Pylightnix to give us the artifacts of `unpack` stage by
**realizing** it. Pylightnix does the dependency handling and decides to execute
both fetchurl and unpack. The results of realization is available via
realization reference `hello_rref`.

```{.python .cb.nb}
hello_rref:RRef = realize_inplace(hello_src)
print(hello_rref)
```
Any RRef could be converted to the system path by calling
[rref2path](../Reference.md#pylightnix.core.rref2path) function or by using a
more feature-rich `mklens`:

```{.python .cb.nb}
from pylightnix import rref2path

print(rref2path(hello_rref))
print(mklens(hello_rref).val)
print(mklens(hello_rref).syspath)
print(mklens(hello_rref).src.syspath)
```

Pylightnix offers a number of other shell-like helper functions for accessing
realization, like `lsref`:

```{.python .cb.nb}
from pylightnix import lsref

print(lsref(hello_rref))
```

### A custom compile stage

In this section we define a custom stage to build the newly obtained sources of
GNU Hello application.

Defining Pylighnix stages requires us to provide Pylightnix with the following
components:

* The JSON-like configuration object.
* The matcher Python function, dealing with non-determenistic builds.
* The realizer Python function which specifies the actual build process.

The matcher business is beyond the scope of this tutorial. We will use a trivial
`match_only` matcher which instructs Pylightnix to expect no more than one
realization of a stage in its storage.

We produce a  `Config` object by returning it from a `_config` function. Note,
that `locals()` is a Python builtin function which returns a `dict` of current
function's local variables.

```{.python .cb.nb}
from pylightnix import Config, mkconfig, mklens, selfref

def hello_config()->Config:
  name = 'hello-bin'
  src = mklens(hello_src).src.refpath
  out_hello = [selfref, 'usr', 'bin', 'hello']
  out_log = [selfref, 'build.log']
  return mkconfig(locals())
```

Realizer is another Python function accepting a `Build` context. We could use
`mklens` to query the parameters of the derivation being built just as we used
it for querying parameters of completed realizations.

```{.python .cb.nb}
from pylightnix import (Path, Build, build_cattrs, build_outpath, build_path,
                        dirrw )

def hello_realize(b:Build)->None:
  with TemporaryDirectory() as tmp:
    copytree(mklens(b).src.syspath,join(tmp,'src'))
    dirrw(Path(join(tmp,'src')))
    cwd = getcwd()
    try:
      chdir(join(tmp,'src'))
      system(f'( ./configure --prefix=/usr && '
             f'  make &&'
             f'  make install DESTDIR={mklens(b).syspath}'
             f')>{mklens(b).out_log.syspath} 2>&1')
    finally:
      chdir(cwd)

```

Finally, we introduce a new stage to Pylightnix by instantiating a generic
[mkdrv](../Reference.md#pylightnix.core.mkdrv) stage:

```{.python .cb.nb}
from pylightnix import mkdrv, build_wrapper, match_only

hello:DRef = \
  instantiate_inplace(mkdrv, hello_config(), match_only(), build_wrapper(hello_realize))

print(hello)
```

As before, we get a `DRef`, which means that basic checks were passed, and
then call a `realize` on it:

```{.python .cb.nb}
rref:RRef=realize_inplace(hello)
print(rref)
```

### Accessing the results

Finally, we convert RRef to the system path and run the GNU Hello binary.

```{.python .cb.nb}
print(Popen([mklens(rref).out_hello.syspath],
            stdout=PIPE, shell=True).stdout.read()) # type:ignore
```


