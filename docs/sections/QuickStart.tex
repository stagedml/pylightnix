\section{Quick start}

We illustrate Pylightnix principles by showing how to use it for making a mock
data science task. We'll follow the
\href{https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.dual_annealing.html}{SciPy
anneal example} but imagine that we want to save some intermediate results and
also that there are several people working on this task.

We start by importing the required Python modules.

\begin{pythontexcode}
import numpy as np
import scipy.optimize as o
import matplotlib.pyplot as plt

from pylightnix import *
\end{pythontexcode}

\subsection{The problem}

The annealing example begins with defining a complex parametric function
\texttt{f} for what we need to find a minimum point as close as possible.

\begin{pythontexcode}
def f(z, *params):
    x, y = z
    a, b, c, d, e, f, g, h, i, j, k, l, scale = params
    return (a * x**2 + b * x * y + c * y**2 + d*x + e*y + f) + \
           (-g*np.exp(-((x-h)**2 + (y-i)**2) / scale)) + \
           (-j*np.exp(-((x-k)**2 + (y-l)**2) / scale))
\end{pythontexcode}

\subsection{Stages basics}

Lets assume that we are to get the \texttt{f}'s parameters from elsewhere and
that we want to get the following results: (a) the starting parameters
themselves (b) the annealing result and statistics and (c) visual plot of the
results.

\subsubsection{Parameter stage}

The Pylightnix \pref{Stage}{pylightnix.types.Stage} is a Python function that
registers a user-defined action in the Manager and returns a
\pref{DRef}{pylightnix.types.DRef} reference stating that the action is
accepted.

\begin{pythontexcode}
def stage_params(m:Manager)->DRef:
  def _config():
    name = 'params'
    out = [selfref, "params.npy"]
    return locals()
  def _make(b:Build):
    np.save(mklens(b).out.syspath, (2, 3, 7, 8, 9, 10, 44, -1, 2, 26, 1, -2, 0.5))
  return mkdrv(m, mkconfig(_config()), match_only(), build_wrapper(_make))
\end{pythontexcode}

The actual registration is done by the \pref{mkdrv}{pylightnix.core.mkdrv}
function which accepts the manager and the following three arguments (a) the
action \pref{Config}{pylightnix.types.Config} object; (b) the
\pref{Matcher}{pylightnix.types.Matcher} callback function; (c) the action
callback accepting the \pref{Build}{pylightnix.types.Build} task description. In
this example we are pretending to receive input parameters from a
thirdparty. We could just as well have downloaded them from the Internet using
the \pref{fetchurl}{pylightnix.stages.fetchurl2} pre-defined stage.

\hfill \break \noindent
A few notes on the above code:

\begin{itemize}
  \item We define configuraiton dictionary by reading a local variables of a
    helper function named \texttt{\_config()}. The resulting dictionary should
    match the \pref{Config}{pylightnix.types.Config} requirements. As often in
    Pylightnix, we use a standalone \pref{mkconfig}{pylightnix.core.mkconfig}
    construcor rather than create the object directly.
  \item By specifying a \texttt{selfref} output path we promise to produce an
    artifact with this name. Pylightnix will throw an error if it does not find
    such an artifact after the build action completes.
  \item When inside the build action, we refer to the pylightnix config items by
    using the \pref{mklens}{pylightnix.lens.mklens} swiss knife helper.
    \texttt{mklens} returns the \pref{Lens}{pylightnix.lens.Lens} object which
    has an overloaded dot "\texttt{.}" operator. The middle part of the lens
    expression encodes the path in the configuration and the last word
    "\texttt{syspath}" encodes the format of the result.
  \item We pass a \pref{match\_only()}{pylightnix.core.match\_only} matcher in
    the third argument of \texttt{mkdrv}. By this we expect our action to return
    a determenistic result. Pylightnix will throw an error if it is not the
    case.
  \end{itemize}

\subsubsection{Annealing stage}

\begin{pythontexcode}
def stage_anneal(m:Manager, ref_params:DRef)->DRef:
  def _config():
    name = 'anneal'
    nonlocal ref_params
    trace_xs = [selfref, 'tracex.npy']
    trace_fs = [selfref, 'tracef.npy']
    out = [selfref, 'result.npy']
    return locals()
  def _make(b:Build):
    params = np.load(mklens(b).ref_params.out.syspath)
    xs = []; fs = []
    def _trace(x,f,ctx):
      nonlocal xs,fs
      xs.append(x.tolist())
      fs.append(f)
    res = o.dual_annealing(f, [[-10,10],[-10,10]],
                         x0=[2.,2.],args=params,
                         maxiter=500, callback=_trace)
    np.save(mklens(b).trace_xs.syspath, np.array(xs))
    np.save(mklens(b).trace_fs.syspath, np.array(fs))
    np.save(mklens(b).out.syspath, res['x'])
  return mkdrv(m, mkconfig(_config()), match_only(), build_wrapper(_make))
\end{pythontexcode}

\subsubsection{Plotting stage}

\begin{pythontexcode}
def stage_plot(m:Manager, ref_anneal:DRef)->DRef:
  def _config():
    name = 'plot'
    nonlocal ref_anneal
    out = [selfref, 'plot.png']
    return locals()
  def _make(b:Build):
    xs=np.load(mklens(b).ref_anneal.trace_xs.syspath)
    fs=np.load(mklens(b).ref_anneal.trace_fs.syspath)
    res=np.load(mklens(b).ref_anneal.out.syspath)
    plt.figure()
    plt.title(f"Min {fs[-1]}, found at {res}")
    plt.plot(range(len(fs)),fs)
    plt.grid(True)
    plt.savefig(mklens(b).out.syspath)
  return mkdrv(m, mkconfig(_config()), match_latest(), build_wrapper(_make))
\end{pythontexcode}

\subsubsection{Running the experiment}

\begin{pythontexcode}
ds=instantiate_inplace(stage_params)
cl=instantiate_inplace(stage_anneal,ds)
vis=instantiate_inplace(stage_plot,cl)
rref=realize_inplace(vis)
print(rref)
\end{pythontexcode}

\mystdout

\subsection{Nested stages}

In the previous sections we implicitly used a global
\pref{Manager}{pylightnix.types.Manager} to register our stages. A more clean
approach requires us to define a nested stage covering the whole experiment.
This way we pospone the problem of choosing which Manager to use.

\begin{pythontexcode}
def stage_all(m:Manager):
  ds=stage_params(m)
  cl=stage_anneal(m,ds)
  vis=stage_plot(m,cl)
  return vis
\end{pythontexcode}

The nested stage may be instantiated and realized in one go.

\begin{pythontexcode}
rref_all=realize(instantiate(stage_all))
assert rref_all==rref
print(rref_all)
\end{pythontexcode}

\mystdout


\subsection{Collaborative work}

Alice and Bob runs the same experiment using their machines. We model
this situation by running Pylightnix with different storage settings.

\begin{pythontexcode}
Sa=mksettings('_storageA')
Sb=mksettings('_storageB')
fsinit(Sa,remove_existing=True)
fsinit(Sb,remove_existing=True)
rrefA=realize(instantiate(stage_all, S=Sa))
rrefB=realize(instantiate(stage_all, S=Sb))
print(rrefA)
print(rrefB)
\end{pythontexcode}

Our annealing problem is stochastic by nature so the results naturally differ.

\subsection{Synchronization}

Alice sends her results to Bob, so he faces a problem of picking the best
realizaion.

\begin{pythontexcode}
print("Bob's storage before the sync:")
for rref in allrrefs(S=Sb):
  print(rref)
arch=Path('archive.zip')
pack([rrefA], arch, S=Sa)
# Alice transfers archive to Bob using her favorite pigeon post service.
unpack(arch, S=Sb)
print("Bob's storage after the sync:")
for rref in allrrefs(S=Sb):
  print(rref)
\end{pythontexcode}

\mystdout


Bob writes a custom matcher that selects the realization which has the best
annealing result.

\begin{pythontexcode}
def match_min(S, rrefs:List[RRef])->List[RRef]:
  avail=[np.load(mklens(rref,S=S).trace_fs.syspath)[-1] for rref in rrefs]
  best=sorted(zip(avail,rrefs))[0]
  if best[1] in allrrefs(Sa):
    print(f"Picking Alice ({best[0]}) out of {avail}")
  else:
    print(f"Picking Bob ({best[0]}) out of {avail}")
  return [best[1]]

def stage_all2(m:Manager):
  ds=stage_params(m)
  cl=redefine(stage_anneal, new_matcher=match_min)(m,ds)
  vis=stage_plot(m,cl)
  return vis

rref_best=realize(instantiate(stage_all2,S=Sb))
print(rref_best)
\end{pythontexcode}

\mystdout
