\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}
\usepackage[russian,english]{babel}
\usepackage{minted}
\renewcommand{\MintedPygmentize}{/nix/store/9r8n35slzprv3q4hfdnc0fz3r70z2y64-python3.7-Pygments-2.7.2/bin/pygmentize}
\usepackage[gobble=auto, rerun=always, pygopt={texcomments=true}]{pythontex}
\usepackage{lscape}
\usepackage[a4paper]{geometry}
\usepackage{pdflscape}
\usepackage{longtable}
\usepackage{hyperref}
\usepackage{mdframed}

\begin{document}

\setpythontexfv{breaklines, breakafter=0123456789-, commandchars=\\\{\}}

\newenvironment{shellcode}
  {\VerbatimEnvironment\begin{minted}[escapeinside=!!, breaklines, breakafter=0123456789-]{sh}}
  {\end{minted}}
\newenvironment{pythoncode}
  {\VerbatimEnvironment\begin{minted}[escapeinside=!!, breaklines, breakafter=0123456789-]{python}}
  {\end{minted}}

\newenvironment{pythontexcode}
  {\VerbatimEnvironment\begin{mdframed}[leftline=false,rightline=false]\begin{pyblock}[stdout][numbers=left]}
  {\end{pyblock}\end{mdframed}}

\newcommand{\mystdout}{\begin{mdframed}\small{\texttt{\stdoutpythontex}}\end{mdframed}}





\selectlanguage{english}

\title{Pylightnix}
\author{Sergey Mironov}
\date{February 2021}
\maketitle


\begin{abstract}

Pylightnix is a Python-based DSL library for manipulating filesystem-based
immutable data objects, inspired by
\href{https://edolstra.github.io/pubs/phd-thesis.pdf}{Purely Functional Software
Deployment Model thesis by Eelco Dolstra} and \href{https://nixos.org}{NixOS}
package manager. In contrast to Nix, Pylightnix is intended to be used in
computer science experiments. Domain-specific package management or
\href{https://en.wikipedia.org/wiki/Blackboard_design_pattern}{blackboard-like
applications} are also among possible use cases.

Pylightnix provides a generic Python API for storing information in the
filesystem. Its main purpose could be summarized as follows:
\begin{itemize}
  \item Declare algorithms for storing arbitrary information in form of linked
    immutable objects here called \textbf{stages}.
  \item Create (in our terms, \textbf{realize}) such objects, access its data,
    navigate through dependencies.
  \item Re-run realization algorithms whenever its inputs changes.  Pylightnix
    will re-create either a whole or a part of the object collection according
    to the changes in prerequisites.
  \item Track the results of non-deterministic realizations. Pylightnix provides
    a generic API for analyzing outcomes of randomized stage realizations. As
    one example, users may instruct Pylightnix stage to depend on top-10 best
    attempts to train a machine learning model.
\end{itemize}

Pylightnix originally appeared as a core module of
\href{https://github.com/stagedml/stagedml}{StagedML} library, later it was
moved into a separate project.

\end{abstract}

\section{Features}

We tried to meet high development standards. In particular, Pylightnix:
\begin{itemize}
  \item Is written in Python 3.6. \href{http://mypy-lang.org/}{Mypy} typing is
    used whenever possible.
  \item Is tested using \href{https://pypi.org/project/hypothesis/}{Hypothesis}.
  \item Documentation is written in
    \href{https://en.wikipedia.org/wiki/Literate_programming}{literate
    programming} paradigm. Most of the code examples shown in this manual were
    checked and evaluated inline by
    \href{https://github.com/gpoore/pythontex}{PythonTex} tool.
  \item Depends solely on the Python standard library. Optional modules
    do depend on \href{https://curl.se/}{Curl},
    \href{https://www.gnu.org/software/wget/}{wget} and
    \href{https://www.nongnu.org/atool/}{atool} system packages.
  \item Alas, Pylightnix is not a production-ready yet! Nor parallelism, neither
    network synchronization are supported out of the box. Also, we didn't check
    Pylightnix on any operating system besides Linux.
    \begin{itemize}
      \item We tried our best to make Pylightnix' operations on storage atomic.
        Among other benefits, this design allows running multiple instances of
        the library on a single storage at once.
      \item Synchronization of different machines should be possible by
        exclusively running `rsync` tool on their storages.
    \end{itemize}
\end{itemize}

\section{Related work}

\begin{itemize}
  \item \href{https://nixos.org}{Nix} (
    \href{https://github.com/nixos/nix}{Nix repo},
    \href{./Comparison.md#Pylightnix-vs-Nix}{Comparison})
  \item \href{https://spack.io}{Spack}
  \item \href{https://falsifiable.us}{Popper}
  \item \href{https://cknowledge.org}{CK}
\end{itemize}

\section{Install}

Pylightnix could be installed either by running Pip package manager as usual or
by bundling the package from source. Since we are in deep betas, you probably
should prefer source-based installation. We will also need
\href{https://curl.se/}{Curl} and \href{https://www.nongnu.org/atool/}{ATool}
system packages later in this manual.

\subsection{Install with Pip}

\begin{shellcode}
$ pip3 install pylightnix
\end{shellcode}

\subsection{Build from source}

\begin{enumerate}
\item Clone the repo
  \begin{shellcode}
  $ git clone https://github.com/stagedml/pylightnix
  $ cd pylightnix
  \end{shellcode}
\item Either
  \begin{itemize}
    \item Setup `PYTHONPATH` to point to the sources.
      \begin{shellcode}
      $ export PYTHONPATH="`pwd`/src:$PYTHONPATH"
      \end{shellcode}
      Now you could import pylightnix from your applications.
    \item Build and install pylightnix wheel.
      \begin{shellcode}
      $ make wheels
      $ sudo -H pip3 install --force dist/*whl
      \end{shellcode}
    \item Nix users may refer to \href{../default.nix}{default.nix} and
      \href{../shell.nix}{shell.nix} expressions.
  \end{itemize}
\item (Optional) Run the tests.
\item (Optional) Make docs
\item (Optional) Build the demos
\end{enumerate}

\subsection{Install recommended system packages}

Pylightnix utilities rely on Curl and ATool system packages. Installing them
is highly advised.

\begin{shellcode}
$ apt-get install -y curl atool      # Use your system's package manager here!
...
$ curl --version | head -n1
curl 7.70.0
$ aunpack --version | head -n1
atool 0.39.0
\end{shellcode}


\section{Quick start}

In this section we illustrate basic principles by defining Pylightnix
\textbf{stages} required to build \href{https://www.gnu.org/software/hello/}{GNU
Hello} program. Resulting stages could be used as a part of e.g. a
project-specific build system (but rather unsafe one, since Pylightnix currently
lacks built-in build isolation).

\begin{enumerate}

  \item Follow the above Install section

  \item Define a stage for fetching the GNU Hello source tarball. Downloading
    files from the Internet is a common task, here we just call a pre-defined
    API function which does the job.

    \begin{pythontexcode}
    from pylightnix import (Manager, DRef, RRef, evaluate, fetchurl)

    hello_version = '2.10'

    def stage_fetch(m:Manager)->DRef: # DRef \label{DREF}
      return fetchurl(m,
        name='hello-src',
        url=f'http://ftp.gnu.org/gnu/hello/hello-{hello_version}.tar.gz',
        sha256='31e066137a962676e89f69d1b65382de95a7ef7d914b8cb956f41ea72e0f516b')

    hello_rref:RRef = evaluate(stage_fetch)  # RRef \label{RREF}
    print(hello_rref)
    \end{pythontexcode}

    Will print:
    \par

    \mystdout

    \par

    \begin{itemize}

      \item At line \ref{DREF} we define an algorithm for creating
        \texttt{hello-src} object. \textbf{fetchurl} function produce stages
        able to download and unpack urls. We simply call it with
        the right arguments and hide this details behind a new name
        \texttt{stage\_fetch}.

      \item At line \ref{RREF} we \textbf{evaluate} our new stage. Pylightnix
        will run the realization algorithm if no matching realization already
        exists. Realizer, in turn, executes \texttt{curl} and \texttt{aunpack}
        applications. As a result, GNU Hello source folder appears in system in
        form of a new \textbf{Realization} object. A unique \textbf{Realization
        reference} is returned to the user.

    \end{itemize}

  \item Our next task is to build the Hello application using common GNU tools.
    Below we show how to define a stage for it using \textbf{mkdrv} API
    function.

    \begin{pythontexcode}
    from tempfile import TemporaryDirectory
    from shutil import copytree
    from os import getcwd, chdir, system
    from os.path import join
    from pylightnix import (Config, Path, Build, mkconfig, mkdrv, mklens,
      build_wrapper, match_only, dirrw, promise, build_setoutpaths)

    def stage_build(m:Manager)->DRef:
      def _config()->Config:
        name:str = 'hello-bin'
        src:RefPath = [stage_fetch(m), f'hello-{hello_version}']
        bin:RefPath = [promise, 'usr', 'bin', 'hello']
        return mkconfig(locals())
      def _realize(b:Build)->None:
        build_setoutpaths(b,1)
        with TemporaryDirectory() as tmp:
          copytree(mklens(b).src.syspath, join(tmp,'src'))
          dirrw(Path(join(tmp,'src')))
          cwd = getcwd()
          try:
            print(f"Building {mklens(b).name.val}")
            chdir(join(tmp,'src'))
            system(f'./configure --prefix=/usr')
            system(f'make')
            system(f'make install DESTDIR={mklens(b).syspath}')
          finally:
            chdir(cwd)
      return mkdrv(m, _config(), match_only(), build_wrapper(_realize))

    hello_rref:RRef = evaluate(stage_build)
    print(hello_rref)
    \end{pythontexcode}

    The output:
    \par
    \mystdout
    \par
  \item Finally, we show how to access the information contained in the
    realization we have built.

    \begin{pythontexcode}
    from subprocess import run, PIPE
    print(run([mklens(hello_rref).bin.syspath], stdout=PIPE).stdout.decode('utf-8'))
    \end{pythontexcode}

    Will print:
    \par
    \mystdout
    \par

\end{enumerate}


\section{Documentation}
bla
\section{Frequently Asked Questions}
bla

\end{document}

