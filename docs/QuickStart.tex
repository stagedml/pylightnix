\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}
\usepackage[russian,english]{babel}
\usepackage{minted}
\renewcommand{\MintedPygmentize}{/nix/store/9r8n35slzprv3q4hfdnc0fz3r70z2y64-python3.7-Pygments-2.7.2/bin/pygmentize}
\usepackage[rerun=always, pygopt={texcomments=true}]{pythontex}
\usepackage{lscape}
\usepackage[a4paper]{geometry}
\usepackage{pdflscape}
\usepackage{longtable}
\usepackage{hyperref}

\begin{document}

\newenvironment{shellcode}
  {\VerbatimEnvironment\begin{minted}[escapeinside=!!, breaklines, breakafter=0123456789-]{sh}}
  {\end{minted}}
\newenvironment{pythoncode}
  {\VerbatimEnvironment\begin{minted}[escapeinside=!!, breaklines, breakafter=0123456789-]{python}}
  {\end{minted}}

\selectlanguage{english}

\title{Pylightnix}
\author{Sergey Mironov}
\date{February 2021}
\maketitle


\begin{abstract}

Pylightnix is a Python-based DSL library for manipulating filesystem-based
immutable data objects, inspired by
\href{https://edolstra.github.io/pubs/phd-thesis.pdf}{Purely Functional Software
Deployment Model thesis by Eelco Dolstra} and \href{https://nixos.org}{NixOS}
package manager. In contrast to Nix, Pylightnix is intended to be used in
computer science experiments. Domain-specific package management or
\href{https://en.wikipedia.org/wiki/Blackboard_design_pattern}{blackboard-like
applications} are also among possible use cases.

Pylightnix provides a generic Python API for storing information in the
filesystem. Its main purpose could be summarized as follows:
\begin{itemize}
  \item Declare algorithms for storing arbitrary information in form of linked
    immutable objects here called \textbf{stages}.
  \item Create (in our terms, \textbf{realize}) such objects, access its data,
    navigate through dependencies.
  \item Re-use the algorithms by monitoring changes in its input
    parameters. Pylightnix will re-create either a whole or a part of the object
    collection according to the changes in realization prerequisites.
  \item Track non-deterministic realizations. Pylightnix provides a generic API
    for analyzing outcomes of randomized stage realizations. For example, users
    may define rules to filter a subset of several machine learning model
    training attempts.
\end{itemize}

Pylightnix originally appeared as a core module of
\href{https://github.com/stagedml/stagedml}{StagedML} library, later it was
moved into a separate project.

\end{abstract}

\section{Features}

We tried to meet high development standards. In particular, Pylightnix:
\begin{itemize}
  \item Is written in Python 3.6. \href{http://mypy-lang.org/}{Mypy} typing is
    used whenever possible.
  \item Is tested using \href{https://pypi.org/project/hypothesis/}{Hypothesis}.
  \item Exclusively depends on the Standard Python library. Optional modules
    also depends on \href{https://curl.se/}{Curl},
    \href{https://www.gnu.org/software/wget/}{wget} and
    \href{https://www.nongnu.org/atool/}{atool} system packages.
  \item Alas, Pylightnix is not a production-ready yet! Nor parallelism, neither
    network synchronization are supported out of the box. Also, we didn't check
    Pylightnix on any operating system besides Linux.
    \begin{itemize}
      \item We tried our best to make Pylightnix' operations on storage atomic.
        Among other benefits, this design allows running multiple instances of
        the library on a single storage at once.
      \item Synchronization of different machines should be possible by
        exclusively running `rsync` tool on their storages.
    \end{itemize}
\end{itemize}

\section{Related work}

\begin{itemize}
  \item \href{https://nixos.org}{Nix} (
    \href{https://github.com/nixos/nix}{Nix repo},
    \href{./Comparison.md#Pylightnix-vs-Nix}{Comparison})
  \item \href{https://spack.io}{Spack}
  \item \href{https://falsifiable.us}{Popper}
  \item \href{https://cknowledge.org}{CK}
\end{itemize}

\section{Install}

As any Python library, you could install Pylightnix either with Pip package
manager or by bundling the package from source. We will also need
\href{https://curl.se/}{Curl} system package and
\href{https://www.nongnu.org/atool/}{ATool} system package later in this manual.

\subsection{Install with Pip}

\begin{shellcode}
$ pip3 install pylightnix
\end{shellcode}

\subsection{Build from source}

\begin{enumerate}
\item Clone the repo
  \begin{shellcode}
  $ git clone https://github.com/stagedml/pylightnix
  $ cd pylightnix
  \end{shellcode}
\item Either
  \begin{itemize}
    \item Setup `PYTHONPATH` to point to the sources.
      \begin{shellcode}
      $ export PYTHONPATH="`pwd`/src:$PYTHONPATH"
      \end{shellcode}
      Now you could import pylightnix from your applications.
    \item Build and install pylightnix wheel.
      \begin{shellcode}
       $ make wheels
       $ sudo -H pip3 install --force dist/*whl
      \end{shellcode}
    \item Nix users may refer to \href{../default.nix}{default.nix} and
      \href{../shell.nix}{shell.nix} expressions.
  \end{itemize}
\item (Optional) Run the tests.
\item (Optional) Make docs
\item (Optional) Build the demos
\end{enumerate}

\subsection{Install recommended system packages}

Pylightnix utilities rely on Curl and ATool system packages. Installing them
is highly advised.

\begin{shellcode}
$ apt-get install -yi curl atool
...
$ curl --version | head -n1
curl 7.70.0
$ aunpack --version | head -n1
atool 0.39.0
\end{shellcode}


\section{Quick start}

This guide illustrates basic principles by defining a
couple of Pylightnix \textbf{stages} able to build
\href{https://www.gnu.org/software/hello/}{GNU Hello} program. Resulting stages
could be used as a part of a lightweight build system (but rather unsafe one,
because Pylightnix lacks built-in build isolation).

\begin{enumerate}

  \item Follow the above Install section

  \item Define the process of \texttt{fetchurl} stage. We use \texttt{\_inplace}
    subset of Pylightnix API for simplicity. It relies on a single global
    variable for storing tracking the build plan.

    \begin{pythoncode}
    from pylightnix import DRef, RRef, instantiate_inplace, fetchurl

    hello_version = '2.10'

    # Define the stage for downloading and unpacking GNU Hello sources.
    hello_src:DRef = \
      instantiate_inplace(
        fetchurl,
        name='hello-src',
        url=f'http://ftp.gnu.org/gnu/hello/hello-{hello_version}.tar.gz',
        sha256='31e066137a962676e89f69d1b65382de95a7ef7d914b8cb956f41ea72e0f516b')

    # Realize the stage in-place and print the realization reference
    hello_rref:RRef = realize_inplace(hello_src)
    print(hello_rref)
    \end{pythoncode}

  \item NEXT
    \begin{pythoncode}
    from tempfile import TemporaryDirectory
    from shutil import copytree
    from os import getcwd, chdir, system
    from os.path import join
    from pylightnix import Config, mkconfig
    from pylightnix import Path, Build, build_cattrs, build_outpath, build_path
    from pylightnix import mkdrv, build_wrapper, match_latest, dirrw

    def hello_config()->Config:
      name:str = 'hello-bin'
      src:RefPath = [hello_src, f'hello-{hello_version}']
      return mkconfig(locals())

    def hello_realize(b:Build)->None:
      c:Any = build_cattrs(b)
      o:Path = build_outpath(b)
      with TemporaryDirectory() as tmp:
        copytree(build_path(b,c.src),join(tmp,'src'))
        dirrw(Path(join(tmp,'src')))
        cwd = getcwd()
        try:
          chdir(join(tmp,'src'))
          system(f'./configure --prefix=/usr')
          system(f'make')
          system(f'make install DESTDIR={o}')
        finally:
          chdir(cwd)

    # Phase 1, create the derivation. Note, we reference previous stage's
    # derivation in the configuration of this derivation.
    hello_dref:DRef = \
        instantiate_inplace(mkdrv, hello_config(), match_latest(), build_wrapper(hello_realize))

    # Phase 2, realize the derivation
    hello_rref:RRef = realize_inplace(hello_dref)

    print(hello_rref)
    \end{pythoncode}

\end{enumerate}


\section{Documentation}
bla
\section{Frequently Asked Questions}
bla

\end{document}

